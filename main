///
//  BP.cpp
//  Assignment_02
//
//  Created by Ilias Batyrbekov on 3/13/20.
//

#include <iostream>
#include <cstdlib>
#include <unistd.h>
#include <pthread.h>
#include <semaphore.h>
#include <sys/types.h>
#include <math.h>
using namespace std;

pthread_mutex_t a_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t t_mutex = PTHREAD_MUTEX_INITIALIZER;

sem_t can_add;
sem_t can_take;
sem_t trans_est;

const int flat_frame_size = 8, cache_capacity = 5,  num_max_retries = 3;
int cache_size = 0, interval; // number of empty slots
int idx_for_push = 0; // index of entry accessed by camera thread
int idx_for_pop = 0; // index of entry accessed by quantizer thread
double* cache[cache_capacity];
double* frame_to_quantize;

//function prototypes
double* generate_frame_vector(int l);
bool is_number(string s);

double sqrt(double d);

bool is_debugging = 1;
bool is_cam_waiting = 0;
bool is_cam_exited = 0;
int num_of_cam_exec = 0;

//bool is_variant_A = 1;

void* camera_method(void *arg)
{
    if (is_debugging) {
        cout<<"camera thread started"<<endl;
    }
    while(1) //exit only if NULL frame is generated
    {
        if (is_debugging) {
            printf("camera started running, num of executions: %d \n", ++num_of_cam_exec);
        }
        if(cache_size>=cache_capacity) //sleep while cache is full
        {
            if (is_debugging) {
                printf("cache is full, camera waiting \n");
            }
            is_cam_waiting = 1;
            sem_wait(&can_add);
            is_cam_waiting = 0;
            if (is_debugging) {
                printf("camera finished waiting \n");
            }
        }

        if (is_debugging) {
            printf("camera in critical section \n");
        }

        bool lock_needed = (idx_for_pop == idx_for_push);
        if (lock_needed)                 // lock a_mutex only if same frame idx
            pthread_mutex_lock(&a_mutex); // is used by camera and quantizers

        //generate flat frame
        double* flat_frame = generate_frame_vector(flat_frame_size);
        if (flat_frame == NULL) //exit
        {
            if (lock_needed)
                pthread_mutex_unlock(&a_mutex);
            is_cam_exited = 1;
            cout<<"\n\n ********************Camera Exited***************** \n\n"<<endl;
            break;
        }
        else//load the frame
        {
            sleep(interval);//simulate loading
            cache[idx_for_push] = flat_frame;
            idx_for_push = (idx_for_push+1) % cache_capacity;
            cache_size++;
            sem_post(&can_take);//notify transformer that there are frames

            if (is_debugging) {
                int temp;
                sem_getvalue(&can_take, &temp);
                // printf("cache size from CAMERA is: %d, and can_take value is: %d \n", cache_size, temp);
            }

            if (lock_needed)
                pthread_mutex_unlock(&a_mutex);
        }
    }
    //finally exit
    pthread_exit(NULL);
}

void* transformer_method(void* args)
{
    int my_temp_id = rand()%2;
    if (is_debugging) {
        cout<<endl<<"transformer thread started"<<endl;
    }

    while (1)
    {
        
        if (is_cam_exited && cache_size == 0) //all frame processed
        {
            cout<<"\n\n ********************Transformer Exited***************** \n\n"<<endl;
            pthread_exit(NULL);
        }
        if (is_debugging)
        {
            int temp;
            sem_getvalue(&can_take, &temp);
            // printf("can_take value in TRANSF (id: %d) BEFORE WAIT is: %d \n", my_temp_id, temp);
        }

        sem_wait(&can_take);//wait for frame to be available

        if (is_debugging)
        {
            int temp;
            sem_getvalue(&can_take, &temp);
            // printf("can take value in TRANSF (id: %d) AFTER WAIT is: %d \n",my_temp_id, temp);
        }

        bool lock_needed = (idx_for_pop == idx_for_push);
        if (lock_needed)
            pthread_mutex_lock(&a_mutex);
//        pthread_mutex_lock(&q_mutex);
        //push frame into cache

         frame_to_quantize = cache[idx_for_pop];

        cache_size--;
        // quantization
        pthread_mutex_lock(&t_mutex);
        for (int i = 0; i<flat_frame_size; i++){
            // cout<<"before "<<frame_to_quantize[i]<<endl;
            double temp = frame_to_quantize[i];
            double increase= 10*temp;
            double r = (int)increase;
            if(increase-r>=0.5){
                frame_to_quantize[i]=(double)(r)/10+0.1;
            }
            else{
                frame_to_quantize[i]=(double)(r)/10;
            }
            // cout<<"after "<<frame_to_quantize[i]<<endl;
        }
        cout<<endl;
        sleep(3);//simulate quantization
        sem_post(&trans_est);
        
        pthread_mutex_unlock(&t_mutex);


        if (is_debugging) {
            int temp;
            sem_getvalue(&can_add, &temp);
            // printf("AFTER CONDITIONAL POST can_add value (trID: %d) is: %d and cache_size is: %d \n",my_temp_id,temp, cache_size);
        }

        //unlock
//        pthread_mutex_unlock(&q_mutex);
        if (lock_needed)
            pthread_mutex_unlock(&a_mutex);
        
    }
}
void* estimator_method(void* args){
    
    if (is_debugging) {
        cout<<endl<<"estimator thread started"<<endl;
    }
    while (1) {
        if (is_cam_exited && cache_size == 0) //all frame processed
        {
            cout<<"\n\n ********************Estimator Excited***************** \n\n"<<endl;
            pthread_exit(NULL);
        }
        cout<<"+++++++++++++++++++++++++++++++++++"<<endl;
        sem_wait(&trans_est);
        cout<<"------------------after sem wait----------------------"<<endl;
        pthread_mutex_lock(&t_mutex);
        cout<<"------------------mutex lock----------------------"<<endl;
        double sum=0;
        cout<<"!!!!!!!!!!!!!!!!!!!!!"<<sum<<"!!!!!!!!!!!!!!!!!!!!!!!!!!!!"<<endl;
        for(int i=0;i<flat_frame_size;i++){
            double * temp=cache[idx_for_pop];
             sum+=pow(temp[i]-frame_to_quantize[i],2);
             cout<<sum<<endl;
        }
        sum=sum/flat_frame_size;
        cout<<"mse = "<<sum<<endl;
        idx_for_pop = (idx_for_pop + 1) % cache_capacity;
        cache_size--;

        if (is_cam_waiting) {
            sem_post(&can_add);//notify camera that there is empty cell
        }
        pthread_mutex_unlock(&t_mutex);

    }
    pthread_exit(NULL);

}




int main(int argc, char** argv)
{
    if (argc != 2) {
        cout << "Error: Insufficient or Exceeding parameters" << endl;
        return 0;
    }
    else if (!is_number(argv[1])) {
        cout << "Error: Parameter should be an integer." << endl;
        return 0;
    }
    interval = stoi(argv[1]);

    //input is legal
    pthread_mutex_init(&a_mutex, NULL);
    pthread_mutex_init(&t_mutex, NULL);
    sem_init(&can_add, 0, 0);
    sem_init(&can_take, 0, 0);
    sem_init(&trans_est,0,0);
    pthread_t threads[3];

    //start camera thread
    if ( pthread_create(&threads[0], NULL, camera_method, NULL) ){
        cout << "Error when creating thread!" << endl;
        exit(-1);
    }
    //start transformer
    if (pthread_create(&threads[1], NULL, transformer_method, NULL)){
        cout << "Error when creating transformer_01 thread!" << endl;
        exit(-1);
    }
    if (pthread_create(&threads[2], NULL, estimator_method, NULL)){
        cout << "Error when creating estimator thread!" << endl;
        exit(-1);
    }

    //wait until camera thread has finished
    if ( pthread_join(threads[0], NULL) ) {
        cout << "Error when camera joining thread!" << endl;
        exit(-1);
    }
    //wait until trans thread has finished
    if ( pthread_join(threads[1], NULL) ) {
        cout << "Error when transf_01 joining thread!" << endl;
        exit(-1);
    }
    if ( pthread_join(threads[2], NULL) ) {
        cout << "Error when estimator joining thread!" << endl;
        exit(-1);
    }


    //finally exit
    pthread_exit(NULL);
}

bool is_number(string s)
{
    string::const_iterator it = s.begin();
    while (it != s.end() && isdigit(*it)) ++it;
    return !s.empty() && it == s.end();
}
 
